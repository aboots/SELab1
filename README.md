به نام خدا

# آزمایش اول آزمایشگاه مهندسی نرم‌افزار (مدیریت نسخ پروژه و یکپارچه‌سازی مستمر)

## مقدمات آزمایش
این مخزن برای نگهداری کد Back-end مربوط به پروژه‌ی Memo Reminder می‌باشد.
Memo Reminder یک اپلیکیشن می‌باشد که برای نگهداری خاطرات شما و مرور آن‌ها به کار می‌آید.
در زیر تصویری از نمای اپلیکیشن‌های آن را مشاهده می‌کنید:

![application](https://github.com/aboots/SELab1/assets/59336942/1eb038d3-159e-42f0-a2e7-e1ad51b71714)

در ادامه به چگونگی انجام آزمایش و مراحل آن می‌پردازیم.

## روال انجام آزمایش
نخست یک ریپازیتوری (همین ریپازیتوری) برای این آزمایش را ساختیم. سپس برای شروع یک کامیت  initialize  زدیم که در آن یک فایل  .gitignore  که برای پروژه‌های پایتون و جنگو مورد استفاده قرار می‌گیرد را قرار دادیم. 

نام‌گذاری برنچ‌ها و مسیج کامیت‌ها همگی مبتنی بر استاندارد Conventional Commits می‌باشند. روند develop هم به این صورت بود که یک برنج master داریم که برنج اصلی (برنچ روی production) می‌باشد. این برچ protected می‌باشد. همانطور که در زیر می‌بینید از طریق setting در زیر بخش branch این rule را اضافه می‌کنیم که برنچ master ما protected باشد و به صورت مستقیم نتوان روی آن مرج انجام داد. هر pull request با انجام دادن review می‌تواند مرج شود. 

![telegram-cloud-document-4-5900171177820688456](https://github.com/aboots/SELab1/assets/59336942/ea78e82d-f94f-4aa1-9a77-624b9b4a31df)

یک برنچ dev نیز داریم که منظور همان برنچ development (برنچ بر روی staging و برای تست) می‌باشد که تمامی برنچ‌های دیگر از این برنچ گرفته می‌شوند و در نهایت با همین برنچ مرج می‌شوند و تنها از develop به برنچ master حق ایجاد pull request را داریم. این بدین منظور است که کد‌ها همینطوری بدون تست شدن وارد کد اصلی master و محیط production نشوند. برای نمونه در زیر یک نمونه از این برنج‌ ساختن از روی dev را می‌بینید:

![telegram-cloud-document-4-5902042125704368010](https://github.com/aboots/SELab1/assets/59336942/847e3ac6-beb0-4a28-9b9d-ccc6c0ac7d91)

همانطور که در زیر می‌بینید یک pull request از dev به مستر ساختیم و بدون review امکان مرج کردن آن وجود ندارد. (مگر با bypass کردن در شرایط ضروری)

![telegram-cloud-document-4-5902422977634373668](https://github.com/aboots/SELab1/assets/59336942/be70eaf5-b3b4-4db5-9ee2-8c8162c286f4)

همچنین در زیر می‌بینید که بعد از review امکان مرج مهیا شده است.

![telegram-cloud-document-4-5904293925518053866](https://github.com/aboots/SELab1/assets/59336942/74f55ad0-d99b-4699-9217-25130951ceec)


نام گذاری برنچ‌های دیگر هم طبق همان استاندارد که در خیلی از شرکت‌های امروزه استفاده می‌شود، می‌باشد. بدین صورت که نام‌گذاری همان نام‌های معروف که داریم مثل feat,fix,chore,docs,test و در ادامه یک اسلش و نام مخصوص آن برنچ می‌آید. در واقع نام اول کتگوری این برنچ را مشخص می‌کند. برای مثال همانطور که در ریپو مشاهده کنید برنچ feat/add_models به این منظور است که این برنچ یک feature اضافه می‌کند و کار خاص آن هم اضافه کردن modelها به پروژه است. یا مثلا اگر برنچی با fix شروع شود برای حل باگ می‌باشد، یا اگر با docs شروع شود مشخص می‌کند که برای document کردن می‌باشد. 
در عکس زیر نمونه‌ای از کامیت‌ها را می‌بینید. کامیت‌هایی که کنار آن‌ها verified دارد به این معنا است که با pull request و review صورت گرفته است. 

![image](https://github.com/aboots/SELab1/assets/59336942/1d54be6b-1b52-4252-9295-d473b33a2650)

در زیر نمونه‌ای از چگونگی مرج کردن یک برنج با dev را می‌بینید.

![telegram-cloud-document-4-5902422977634373670](https://github.com/aboots/SELab1/assets/59336942/c8c8c8d4-4847-4833-83cf-d22ee402e0cc)

در زیر نمونه‌ای از یک برنچ جدید ساختن و پوش بر روی آن را می‌بینید.

![telegram-cloud-document-4-5902042125704368008](https://github.com/aboots/SELab1/assets/59336942/de359e94-d676-46f8-aaac-4c26946a0b93)

همچنین در طول پروژه به ۳ کانفلیکت خوردیم که آن‌ها را به صورت دستی از توی terminal و بدون کمک از IDE حل کردیم. در زیر نمونه‌ای از آن را که در هنگام merge یک برنچ با dev رخ داد را می‌بینید:

![telegram-cloud-document-4-5902042125704368018](https://github.com/aboots/SELab1/assets/59336942/a83590ff-ec69-4d37-91c7-c1953fb0e07c)
![telegram-cloud-document-4-5902042125704368015](https://github.com/aboots/SELab1/assets/59336942/9dd59ae3-5eba-4c2a-894f-08da583eee87)
![telegram-cloud-document-4-5902042125704368019](https://github.com/aboots/SELab1/assets/59336942/aedddfb6-234b-4538-9249-9689fc7cfd91)

در زیر نمونه‌ای دیگر از conflict که در یک branch رخ داد و حل آن را می‌بینید.

![Screenshot 2023-10-29 105310](https://github.com/aboots/SELab1/assets/59165380/c064dace-fd0a-4039-8533-0307c9e597ea)
![Screenshot 2023-10-29 105708](https://github.com/aboots/SELab1/assets/59165380/1eb78d77-d0c4-47f6-a27c-396ff2f2f51f)


## پرسش‌ها

1. پوشه‌ی .git چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟

پوشه .git یک پوشه مخفی است که هنگام ایجاد یک مخزن Git جدید با دستور git init یا git clone (وقتی که یک پروژه که از قبل به گیت متصل بوده را clone کنیم، از همان اول پوشه git. موجود خواهد بود) ساخته می‌شود. این پوشه شامل تمام اطلاعات لازم برای ذخیره‌‌سازی و سازماندهی ورژن‌های فایل‌های مختلف پروژه می‌باشد. برخی از بخش‌های اصلی آن عبارتند از: hooks، info، objects، refs، HEAD، config، description، index و... . برای مثال دایرکتوری refs شامل پوینتر‌ها به آبجکت‌های کامیت‌ها است. فایل HEAD به شاخه فعلی اشاره می‌کند و... . فایل config شامل آپشن‌های تنظیمات است. به طور کلی می‌توان گفت هر چیزی که مربوط به تاریخچه کامیت‌ها، اطلاعات ریپازیتوری‌های ریموت، کامیت و درخت زیرپوشه‌ها، تنظیمات امنیتی و... باشد در این پوشه ذخیره می‌شود.

2. منظور از atomic بودن در atomic commit و atomic pull-request چیست؟

به طور کلی اتمیک بودن یعنی تک منظوره و تجزیه‌ناپذیر بودن. در کامیت، اتمیک بودن به این معناست که تنها نشان‌دهنده یک تغییر اعم از اضافه کردن فیچری، رفع کردن باگی و... باشد و نتوان آن را به اجزا ریز‌دانه‌تری تجزیه کرد. البته این به این معنا نیست که در هر کامیت، تغییرات باید تنها به یک فایل خاص محدود شود. اتمیک بودن در مورد pull request‌ها نیز به همین معناست. ارزشی که هر pull request به نرم‌افزار اضافه می‌کند باید تک‌منظوره و سطح پایین باشد. تغییر درشت‌دانه‌تری که در نرم‌افزار اتفاق می‌افتد باید شامل مجموعه‌ای از pull request‌های اتمیک باشد. مزیتی که اتمیک بودن دارد این است که فرآیند دیباگینگ و دلیوری و بازگرداندن تغییرات و خطا‌های بالقوه را آسان‌تر می‌کند. همچنین در راستای یک تغییر، اگر همه تغییرات اتمیک مرتبط با آن با موفقیت انجام شود، در نهایت آن تغییر با موفقیت اتفاق می‌افتد و در صورت بروز خطا در یکی از آن‌ها، قبل از تکمیل شدن تغییر برگشت داده می‌شوند.

3. تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick را بیان کنید.    
دستور fetch: آخرین محتویات ریپازیتوری ریموت را به ریپازیتوری لوکال انتقال می‌دهد ولی در فایل‌های موجود تغییری نمی‌دهد یا به عبارتی working directory را تغییر نمی‌دهد.
 
دستور pull: این دستور علاوه بر کاری که دستور fetch انجام می‌دهد، محتویات فایل‌ها را تغییر می‌دهد یا به عبارتی merge‌ می‌کند. دستور pull در واقع ترکیب دستور‌های fetch و merge FETCH_HEAD می باشد.  

دستور merge: تغییرات شاخه‌های مختلف را که تاریخچه کامیت‌های آن‌ها از شاخه فعلی جدا شده است را با شاخه فعلی ادغام می‌کند و یک کامیت merge ایجاد می‌کند. این دستور تاریخچه شاخه‌های موجود را تغییری نمی دهد.

دستور rebase: مشابه دستور merge تغییرات یک شاخه را به شاخه دیگر منتقل می‌کند ولی بر خلاف دستور merge تاریخچه پروژه را تغییر می‌دهد و starting point شاخه مورد توسعه تغییر می‌کند. در این دستور کامیت merge ایجاد نمی‌شود.  

دستور cherry-pick: این دستور این امکان را فراهم می‌کند که کامیت‌های دلخواه از شاخه‌های مختلف را با رفرنس آن‌ها برداریم و به WORKING_HEAD شاخه فعلی append کنیم. از این دستور می‌توان در مواردی که به اشتباه یک کامیت در یک شاخه اشتباه ایجاد شده و می‌خواهیم آن را به شاخه درست منتقل کنیم، استفاده کرد.  

4. تفاوت دستورهای reset و revert و restore را بیان کنید.  
دستور reset: برای بازگرداندن شاخه فعلی به یک کامیت خاص استفاده می‌شود یا با پاک کردن یا با تغییر دادن کامیت‌های جلوتر. این دستور ۳ نوع soft، mixed و hard دارد. این دستور در واقع HEAD را به کامیت مد‌نظر می‌برد.  

دستور revert: این دستور یک کامیت جدید ایجاد می‌کند و تاثیر یک کامیت خاص را خنثی می کند. بنابراین بر خلاف دستور reset، تاریخچه کامیت‌ها حفظ می‌شود و از بین نمی‌رود.  

دستور restore: برای بازگرداندن فایل‌ها به محتویات یک کامیت خاص یا ایندکس کاربرد دارد. این دستور نیز آپشن‌های متفاوتی مانند staged-- یا source-- دارد. که source-- وضعیت را به کامیت مشخص‌شده برمی‌گرداند و staged-- تغییرات را unstage می‌کند که معادل دستور git reset می‌شود.  
5. منظور از stage چیست؟ دستور stash چه کاری را انجام می‌دهد؟  
استیج یک مرحله میانی قبل از کامیت کردن است که تغییرات ابتدا در این ناحیه آماده می‌شوند و فایل‌های تغییر یافته با دستور git add به این ناحیه وارد می‌شوند. می‌توان فقط تعدادی از فایل‌های تغییر یافته و نه همه آن‌ها را به این ناحیه وارد کرد. با دستور git commit فایل‌هایی که در ناحیه استیج باشند، کامیت خواهند شد.  
دستور stash: این دستور تغییراتی که هنوز آماده کامیت شدن نیستند را ذخیره می‌کند (چه استیج شده باشد چه نشده باشد). این دستور به شما اجازه می‌دهد تا روی یک کار دیگری مثلا سوییچ کردن روی یک شاخه دیگر و جلو بردن آن بپردازید و تغییرات ناکاملی که اکنون ایجاد کرده‌اید را بعدا به آن‌ها بپردازید. برای اینکه بعدا این تغییرات را بتوان بازیابی کرد از دستور git stash apply یا git stash pop استفاده می‌شود که apply‌ آخرین stash را دور نمی‌ریزد ولی pop اینکار را می‌کند.  
6. مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟  
در گیت اسنپشات به معنای یک نسخه کامل از ریپازیتوری در یک لحظه خاص می‌باشد که شامل همه فایل‌های ریپازیتوری در آن لحظه می‌باشد. هر کامیت در گیت نشانگر یک اسنپشات از directory tree کل پروژه در زمان آن کامیت می‌باشد. هر کامیت یک commit id که یک هش SHA-1 منحصر به فرد است، دارد و با استفاده از آن می‌توان به اسنپشات مد‌نظر خود دسترسی پیدا کرد.  
