به نام خدا

# آزمایش اول آزمایشگاه مهندسی نرم‌افزار (مدیریت نسخ پروژه و یکپارچه‌سازی مستمر)

## مقدمات آزمایش
این مخزن برای نگهداری کد Back-end مربوط به پروژه‌ی Memo Reminder می‌باشد.
Memo Reminder یک اپلیکیشن می‌باشد که برای نگهداری خاطرات شما و مرور آن‌ها به کار می‌آید.
در زیر تصویری از نمای اپلیکیشن‌های آن را مشاهده می‌کنید:

![application](https://github.com/aboots/SELab1/assets/59336942/1eb038d3-159e-42f0-a2e7-e1ad51b71714)

در ادامه به چگونگی انجام آزمایش و مراحل آن می‌پردازیم.

## روال انجام آزمایش
نخست یک ریپازیتوری (همین ریپازیتوری) برای این آزمایش را ساختیم. سپس برای شروع یک کامیت ``` initialize ``` زدیم که در آن یک فایل ``` .gitignore ``` که برای پروژه‌های پایتون و جنگو مورد استفاده قرار می‌گیرد را قرار دادیم. 

نام‌گذاری برنچ‌ها و مسیج کامیت‌ها همگی مبتنی بر استاندارد Conventional Commits می‌باشند. روند develop هم به این صورت بود که یک برنج master داریم که برنج اصلی (برنچ روی production) می‌باشد. این برچ protected می‌باشد. همانطور که در زیر می‌بینید از طریق setting در زیر بخش branch این rule را اضافه می‌کنیم که برنچ master ما protected باشد و به صورت مستقیم نتوان روی آن پوش یا مرج کرد. هر pull request با انجام دادن review می‌تواند مرج شود. 

![telegram-cloud-document-4-5900171177820688456](https://github.com/aboots/SELab1/assets/59336942/ea78e82d-f94f-4aa1-9a77-624b9b4a31df)

یک برنچ dev نیز داریم که منظور همان برنچ development (برنچ بر روی staging و برای تست) می‌باشد که تمامی برنچ‌های دیگر از این برنچ گرفته می‌شوند و در نهایت با همین برنچ مرج می‌شوند و تنها از develop به برنچ master حق ایجاد pull request را داریم. این بدین منظور است که کد‌ها همینطوری بدون تست شدن وارد کد اصلی master و محیط production نشوند. برای نمونه در زیر یک نمونه از این برنج‌ ساختن از روی dev را می‌بینید:

![telegram-cloud-document-4-5902042125704368010](https://github.com/aboots/SELab1/assets/59336942/847e3ac6-beb0-4a28-9b9d-ccc6c0ac7d91)

همانطور که در زیر می‌بینید یک pull request از یثر به مستر ساختیم و بدون review امکان مرج کردن آن وجود ندارد. (مگر با bypass کردن در شرایط ضروری)

![telegram-cloud-document-4-5902422977634373668](https://github.com/aboots/SELab1/assets/59336942/be70eaf5-b3b4-4db5-9ee2-8c8162c286f4)

همچنین در زیر می‌بینید که بعد از review امکان مرج مهیا شده است.

![telegram-cloud-document-4-5904293925518053866](https://github.com/aboots/SELab1/assets/59336942/74f55ad0-d99b-4699-9217-25130951ceec)


نام گذاری برنچ‌های دیگر هم طبق همان استاندارد که در خیلی از شرکت‌های امروزه استفاده می‌شود، می‌باشد. بدین صورت که نام‌گذاری همان نام‌های معروف که داریم مثل ```feat,fix,chore,docs,test``` و در ادامه یک اسلش و نام مخصوص آن برنچ می‌آید. در واقع نام اول کتگوری این برنچ را مشخص می‌کند. برای مثال همانطور که در ریپو مشاهده کنید برنچ ```feat/add_models``` به این منظور است که این برنچ یک feature اضافه می‌کند و کار خاص آن هم اضافه کردن modelها به پروژه است. یا مثلا اگر برنچی با fix شروع شود برای حل باگ می‌باشد، یا اگر با docs شروع شود مشخص می‌کند که برای document کردن می‌باشد. 
در عکس زیر نمونه‌ای از کامیت‌ها را می‌بینید. کامیت‌هایی که کنار آن‌ها verified دارد به این معنا است که با pull request و review صورت گرفته است. 

![image](https://github.com/aboots/SELab1/assets/59336942/1d54be6b-1b52-4252-9295-d473b33a2650)

در زیر نمونه‌ای از چگونگی مرج کردن یک برنج با dev را می‌بینید.

![telegram-cloud-document-4-5902422977634373670](https://github.com/aboots/SELab1/assets/59336942/c8c8c8d4-4847-4833-83cf-d22ee402e0cc)

در زیر نمونه‌ای از یک برنچ جدید ساختن و پوش بر روی آن را می‌بینید.

![telegram-cloud-document-4-5902042125704368008](https://github.com/aboots/SELab1/assets/59336942/de359e94-d676-46f8-aaac-4c26946a0b93)

همچنین در طول پروژه به ۳ کانفلیکت خوردیم که آن‌ها را به صورت دستی از توی terminal و بدون کمک از IDE حل کردیم. در زیر نمونه‌ای از آن را که در هنگام merge یک برنچ با dev رخ داد را می‌بینید:

![telegram-cloud-document-4-5902042125704368018](https://github.com/aboots/SELab1/assets/59336942/a83590ff-ec69-4d37-91c7-c1953fb0e07c)
![telegram-cloud-document-4-5902042125704368015](https://github.com/aboots/SELab1/assets/59336942/9dd59ae3-5eba-4c2a-894f-08da583eee87)
![telegram-cloud-document-4-5902042125704368019](https://github.com/aboots/SELab1/assets/59336942/aedddfb6-234b-4538-9249-9689fc7cfd91)

در زیر نمونه‌ای دیگر از conflict که در یک branch رخ داد و حل آن را می‌بینید.

![Screenshot 2023-10-29 105310](https://github.com/aboots/SELab1/assets/59165380/c064dace-fd0a-4039-8533-0307c9e597ea)
![Screenshot 2023-10-29 105708](https://github.com/aboots/SELab1/assets/59165380/1eb78d77-d0c4-47f6-a27c-396ff2f2f51f)


## پرسش‌ها

1. پوشه‌ی .git چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟

پوشه .git یک پوشه مخفی است که هنگام ایجاد یک مخزن Git جدید با دستور git init یا git clone (وقتی که یک پروژه که از قبل به گیت متصل بوده را clone کنیم، از همان اول پوشه git. موجود خواهد بود) ساخته می‌شود. این پوشه شامل تمام اطلاعات لازم برای ذخیره‌‌سازی و سازماندهی ورژن‌های فایل‌های مختلف پروژه می‌باشد. برخی از بخش‌های اصلی آن عبارتند از: hooks، info، objects، refs، HEAD، config، description، index و... . برای مثال دایرکتوری refs شامل پوینتر‌ها به آبجکت‌های کامیت‌ها است. فایل HEAD به شاخه فعلی اشاره می‌کند و... . فایل config شامل آپشن‌های تنظیمات است. به طور کلی می‌توان گفت هر چیزی که مربوط به تاریخچه کامیت‌ها، اطلاعات ریپازیتوری‌های ریموت، کامیت و درخت زیرپوشه‌ها، تنظیمات امنیتی و... باشد در این پوشه ذخیره می‌شود.

2. منظور از atomic بودن در atomic commit و atomic pull-request چیست؟

به طور کلی اتمیک بودن یعنی تک منظوره و تجزیه‌ناپذیر بودن. در کامیت، اتمیک بودن به این معناست که تنها نشان‌دهنده یک تغییر اعم از اضافه کردن فیچری، رفع کردن باگی و... باشد و نتوان آن را به اجزا ریز‌دانه‌تری تجزیه کرد. البته این به این معنا نیست که در هر کامیت، تغییرات باید تنها به یک فایل خاص محدود شود. اتمیک بودن در مورد pull request‌ها نیز به همین معناست. ارزشی که هر pull request به نرم‌افزار اضافه می‌کند باید تک‌منظوره و سطح پایین باشد. تغییر درشت‌دانه‌تری که در نرم‌افزار اتفاق می‌افتد باید شامل مجموعه‌ای از pull request‌های اتمیک باشد. مزیتی که اتمیک بودن دارد این است که فرآیند دیباگینگ و دلیوری و بازگرداندن تغییرات و خطا‌های بالقوه را آسان‌تر می‌کند. همچنین در راستای یک تغییر، اگر همه تغییرات اتمیک مرتبط با آن با موفقیت انجام شود، در نهایت آن تغییر با موفقیت اتفاق می‌افتد و در صورت بروز خطا در یکی از آن‌ها، قبل از تکمیل شدن تغییر برگشت داده می‌شوند.

4. تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick را بیان کنید.
5. تفاوت دستورهای reset و revert و restore را بیان کنید.
6. منظور از stage چیست؟ دستور stash چه کاری را انجام می‌دهد؟
7. مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟
